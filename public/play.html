<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Play Game - VibeCodeKidz</title>
  <meta name="description" content="Play this game built by a kid on VibeCodeKidz ‚Äî the AI-powered game creation platform for ages 7-18." />
  <meta name="theme-color" content="#1a1a2e" />

  <meta property="og:type" content="website" />
  <meta property="og:title" content="Play Game - VibeCodeKidz" />
  <meta property="og:description" content="Play this game built by a kid on VibeCodeKidz ‚Äî the AI-powered game creation platform." />
  <meta property="og:image" content="https://vibecodekidz.org/og-image.png" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Play Game - VibeCodeKidz" />
  <meta name="twitter:description" content="Play this game built by a kid on VibeCodeKidz." />
  <meta name="twitter:image" content="https://vibecodekidz.org/og-image.png" />

  <link rel="icon" type="image/svg+xml" href="/rocket.svg" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <link rel="manifest" href="/manifest.json" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&family=Orbitron:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    *, *::before, *::after {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    html {
      height: 100%;
      overflow: hidden;
    }
    
    body {
      font-family: 'Nunito', sans-serif;
      height: 100vh;
      height: 100dvh;
      color: white;
      background: linear-gradient(135deg, 
        #1a1a2e 0%, 
        #16213e 25%, 
        #0f3460 50%, 
        #1a1a2e 75%,
        #16213e 100%
      );
      background-attachment: fixed;
      overflow: hidden;
    }
    
    /* Background orbs */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(236, 72, 153, 0.2) 0%, transparent 50%),
        radial-gradient(circle at 40% 40%, rgba(52, 211, 153, 0.15) 0%, transparent 40%);
      pointer-events: none;
      z-index: 0;
    }
    
    /* Loading State */
    .loading-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 20px;
      position: relative;
      z-index: 1;
    }
    
    .loading-spinner {
      width: 60px;
      height: 60px;
      border: 4px solid rgba(255, 255, 255, 0.2);
      border-top-color: #a78bfa;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .loading-text {
      font-size: 1.25rem;
      opacity: 0.9;
    }
    
    /* Error State */
    .error-container {
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 20px;
      text-align: center;
      position: relative;
      z-index: 1;
    }
    
    .error-emoji {
      font-size: 4rem;
      margin-bottom: 20px;
    }
    
    .error-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 2rem;
      margin-bottom: 12px;
    }
    
    .error-message {
      font-size: 1.1rem;
      opacity: 0.8;
      margin-bottom: 24px;
    }
    
    .glass-btn {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 16px 32px;
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.6) 0%, rgba(236, 72, 153, 0.6) 100%);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: white;
      border-radius: 50px;
      font-size: 1rem;
      font-weight: 700;
      cursor: pointer;
      text-decoration: none;
      transition: all 0.3s ease;
    }
    
    .glass-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 30px rgba(139, 92, 246, 0.4);
    }
    
    /* Play Mode */
    .play-container {
      display: none;
      flex-direction: column;
      height: 100vh;
      height: 100dvh;
      position: relative;
      z-index: 1;
      overflow: hidden;
    }
    
    .play-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 24px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-bottom: 1px solid rgba(255, 255, 255, 0.15);
      flex-wrap: wrap;
      gap: 16px;
      flex-shrink: 0;
    }
    
    .project-info {
      display: flex;
      align-items: center;
      gap: 20px;
      flex-wrap: wrap;
    }
    
    .project-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.25rem;
      font-weight: 700;
    }
    
    .project-creator {
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.7);
    }
    
    .project-creator span {
      color: #38bdf8;
    }
    
    .project-stats {
      display: flex;
      gap: 16px;
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.7);
    }
    
    .header-actions {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    
    .action-btn {
      padding: 12px 20px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      color: white;
      border-radius: 50px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      text-decoration: none;
    }
    
    .action-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-2px);
    }
    
    .action-btn.primary {
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.6) 0%, rgba(236, 72, 153, 0.6) 100%);
      border-color: rgba(255, 255, 255, 0.25);
    }
    
    .action-btn.primary:hover {
      box-shadow: 0 4px 20px rgba(139, 92, 246, 0.3);
    }
    
    .action-btn.like {
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.6) 0%, rgba(249, 115, 22, 0.6) 100%);
      border-color: rgba(255, 255, 255, 0.25);
    }
    
    .action-btn.like:hover {
      box-shadow: 0 4px 20px rgba(239, 68, 68, 0.3);
    }
    
    .play-content {
      flex: 1;
      padding: 12px;
      position: relative;
      min-height: 0;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    .project-iframe {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      height: 100%;
      max-width: 1200px;
      border: none;
      border-radius: 20px;
      background: white;
      box-shadow: 0 25px 80px rgba(0, 0, 0, 0.5);
      display: block;
    }
    
    .action-btn.fullscreen-btn {
      background: linear-gradient(135deg, rgba(52, 211, 153, 0.6) 0%, rgba(56, 189, 248, 0.6) 100%);
      border-color: rgba(255, 255, 255, 0.25);
    }
    
    .action-btn.fullscreen-btn:hover {
      box-shadow: 0 4px 20px rgba(52, 211, 153, 0.3);
    }
    
    .play-footer {
      padding: 16px 24px;
      text-align: center;
      background: rgba(0, 0, 0, 0.2);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      flex-shrink: 0;
    }
    
    .play-footer a {
      color: #a78bfa;
      text-decoration: none;
      font-weight: 600;
    }
    
    .play-footer a:hover {
      text-decoration: underline;
    }
    
    /* Fullscreen mode */
    .fullscreen .play-header,
    .fullscreen .play-footer {
      display: none;
    }
    
    .fullscreen .play-content {
      padding: 0;
    }
    
    .fullscreen .project-iframe {
      top: 0;
      left: 0;
      transform: none;
      width: 100%;
      height: 100vh;
      height: 100dvh;
      max-width: none;
      border-radius: 0;
    }
    
    .fullscreen-exit {
      display: none;
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      padding: 14px 28px;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: white;
      border-radius: 50px;
      font-weight: 700;
      cursor: pointer;
    }
    
    .fullscreen .fullscreen-exit {
      display: block;
    }
    
    @media (max-width: 1024px) {
      .play-content {
        padding: 4px;
      }

      .project-iframe {
        max-width: 100%;
        border-radius: 8px;
      }

      .play-footer {
        padding: 8px 12px;
        font-size: 0.75rem;
      }
    }

    @media (max-width: 768px) {
      .play-header {
        padding: 4px 8px;
        gap: 0;
        flex-shrink: 0;
        flex-wrap: nowrap;
        align-items: center;
      }
      
      .project-info {
        flex-direction: row;
        align-items: center;
        gap: 6px;
        flex-wrap: nowrap;
        overflow: hidden;
        flex: 1;
        min-width: 0;
      }

      .project-title {
        font-size: 0.85rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .project-creator,
      .project-stats {
        display: none;
      }
      
      .header-actions {
        display: flex;
        gap: 4px;
        flex-wrap: nowrap;
        flex-shrink: 0;
      }

      .action-btn {
        padding: 6px 8px;
        font-size: 0.7rem;
        min-height: 36px;
        white-space: nowrap;
        flex-shrink: 0;
        border-radius: 8px;
      }

      .action-btn .btn-emoji {
        display: none;
      }

      .play-content {
        padding: 0;
        flex: 1;
        min-height: 0;
      }

      .project-iframe {
        border-radius: 0;
        width: 100%;
        height: 100%;
        max-width: 100%;
      }

      .play-footer {
        display: none;
      }
    }
    
    @media (max-width: 480px) {
      .action-btn {
        padding: 6px 6px;
        font-size: 0.65rem;
      }
    }
  </style>
</head>
<body>
  <!-- Loading State -->
  <div id="loading" class="loading-container">
    <div class="loading-spinner"></div>
    <p class="loading-text">Loading creation...</p>
  </div>
  
  <!-- Error State -->
  <div id="error" class="error-container">
    <div class="error-emoji">üò¢</div>
    <h1 class="error-title">Oops! Project Not Found</h1>
    <p class="error-message">This creation might have been moved or deleted.</p>
    <a href="/" class="glass-btn">üöÄ Open Studio</a>
  </div>
  
  <!-- Play State -->
  <div id="play" class="play-container">
    <header class="play-header">
      <div class="project-info">
        <span class="project-title" id="projectTitle">Loading...</span>
        <span class="project-creator">by <span id="creatorName">...</span></span>
        <div class="project-stats">
          <span>üëÅÔ∏è <span id="viewCount">0</span> views</span>
          <span>‚ù§Ô∏è <span id="likeCount">0</span> likes</span>
        </div>
      </div>
      <div class="header-actions">
        <button class="action-btn refresh" onclick="refreshProject()" title="Reload latest code from Studio">
          <span class="btn-emoji">üîÑ</span> Refresh
        </button>
        <button class="action-btn like" onclick="likeProject(event)">
          <span class="btn-emoji">‚ù§Ô∏è</span> Like
        </button>
        <button class="action-btn fullscreen-btn" onclick="toggleFullscreen()">
          <span class="btn-emoji">üñ•Ô∏è</span> Fullscreen
        </button>
        <a href="/gallery" class="action-btn">
          <span class="btn-emoji">üéÆ</span> More
        </a>
        <a href="/" class="action-btn primary">
          <span class="btn-emoji">üöÄ</span> Studio
        </a>
      </div>
    </header>
    
    <main class="play-content">
      <iframe id="projectIframe" class="project-iframe" sandbox="allow-scripts allow-same-origin allow-pointer-lock" title="Game player"></iframe>
    </main>
    
    <footer class="play-footer">
      Made with <a href="/">Vibe Code Studio</a> - Where kids learn to build awesome stuff! üöÄ
    </footer>
    
    <button class="fullscreen-exit" onclick="toggleFullscreen()">‚úï Exit Fullscreen</button>
  </div>
  
  <script>
    let currentProject = null;
    let ws = null;
    let myPlayerId = null;
    let currentRoomCode = null;
    let players = [];
    let pendingMultiplayerInject = false;
    let wsConnectTimeout = null;
    let pendingCreateRoom = null;
    let pendingJoinRoom = null;
    
    // Get project ID from URL
    function getProjectId() {
      const path = window.location.pathname;
      const match = path.match(/\/play\/([a-z0-9]+)/);
      return match ? match[1] : null;
    }
    
    const isPreviewMode = new URLSearchParams(window.location.search).has('preview');

    // In preview mode, hide all UI except the game iframe
    if (isPreviewMode) {
      document.querySelectorAll('.mobile-header, .play-info, .play-sidebar, .multiplayer-section, .play-footer, .back-link').forEach(
        el => { if (el) el.style.display = 'none'; }
      );
    }

    // Load project
    async function loadProject() {
      const projectId = getProjectId();
      
      if (!projectId) {
        showError();
        return;
      }
      
      try {
        const response = await fetch(`/api/projects/${projectId}`);
        
        if (!response.ok) {
          showError();
          return;
        }
        
        const project = await response.json();
        currentProject = project;
        displayProject(project);
      } catch (err) {
        console.error('Error loading project:', err);
        showError();
      }
    }
    
    async function refreshProject() {
      const projectId = getProjectId();
      if (!projectId) return;

      const btn = document.querySelector('.action-btn.refresh');
      if (btn) { btn.disabled = true; btn.innerHTML = '<span class="btn-emoji">‚è≥</span> Loading...'; }

      try {
        const response = await fetch(`/api/projects/${projectId}`);
        if (response.ok) {
          const project = await response.json();
          currentProject = project;
          displayProject(project);
        }
      } catch (err) {
        console.error('Error refreshing project:', err);
      } finally {
        if (btn) { btn.disabled = false; btn.innerHTML = '<span class="btn-emoji">üîÑ</span> Refresh'; }
      }
    }

    // Display project (load game into iframe, show play container)
    function displayProject(project, mode) {
      // Update page title
      document.title = `${project.title} - Vibe Code Arcade`;
      
      // Update UI
      document.getElementById('projectTitle').textContent = project.title;
      document.getElementById('creatorName').textContent = project.creatorName;
      document.getElementById('viewCount').textContent = project.views || 0;
      document.getElementById('likeCount').textContent = project.likes || 0;
      updateLikeButton();
      
      // Load code into iframe using srcdoc (avoids about:blank race condition)
      const iframe = document.getElementById('projectIframe');
      const isMultiplayer = !isPreviewMode && currentProject && currentProject.multiplayer;

      // For multiplayer games, prepend the VibeMultiplayer API directly into the HTML
      // so it's available BEFORE the game's window.onload fires.
      let codeToWrite = project.code;
      if (isMultiplayer) {
        const roomCodeJson = JSON.stringify(currentRoomCode || null);
        const playersJson = JSON.stringify(players).replace(/<\/script>/gi, '<\\/script>');
        const playerIdEsc = (myPlayerId || '').replace(/\\/g, '\\\\').replace(/'/g, "\\'");
        const mpBootstrap = '<scr' + 'ipt>' +
          '(function(){' +
          'window.VibeMultiplayer={' +
            'roomCode:' + roomCodeJson + ',' +
            "playerId:'" + playerIdEsc + "'," +
            'players:' + playersJson + ',' +
            "createRoom:function(n){window.parent.postMessage({type:'mp_create_room',playerName:(n||'Player').toString().trim().slice(0,20)||'Player'},'*')}," +
            "joinRoom:function(c,n){window.parent.postMessage({type:'mp_join_room',roomCode:String(c||''),playerName:(n||'Player').toString().trim().slice(0,20)||'Player'},'*')}," +
            "leaveRoom:function(){window.parent.postMessage({type:'mp_leave_room'},'*')}," +
            "sendState:function(s){window.parent.postMessage({type:'mp_state',state:s},'*')}," +
            "sendInput:function(i){window.parent.postMessage({type:'mp_input',input:i},'*')}," +
            'onRoomCreated:null,onRoomJoined:null,onRoomLeft:null,onError:null,' +
            'onStateReceived:null,onInputReceived:null,onPlayerJoined:null,onPlayerLeft:null' +
          '};' +
          "window.addEventListener('message',function(e){" +
            'var d=e.data;' +
            "if(d.type==='mp_room_created'){" +
              'if(d.playerId)window.VibeMultiplayer.playerId=d.playerId;' +
              'window.VibeMultiplayer.roomCode=d.roomCode;' +
              'window.VibeMultiplayer.players=d.players||[];' +
              'if(window.VibeMultiplayer.onRoomCreated)window.VibeMultiplayer.onRoomCreated(d.roomCode,d.players);' +
            "}else if(d.type==='mp_room_joined'){" +
              'if(d.playerId)window.VibeMultiplayer.playerId=d.playerId;' +
              'window.VibeMultiplayer.roomCode=d.roomCode;' +
              'window.VibeMultiplayer.players=d.players||[];' +
              'if(window.VibeMultiplayer.onRoomJoined)window.VibeMultiplayer.onRoomJoined(d.roomCode,d.players);' +
            "}else if(d.type==='mp_room_left'){" +
              'window.VibeMultiplayer.roomCode=null;window.VibeMultiplayer.players=[];' +
              'if(window.VibeMultiplayer.onRoomLeft)window.VibeMultiplayer.onRoomLeft();' +
            "}else if(d.type==='mp_error'){" +
              "if(window.VibeMultiplayer.onError)window.VibeMultiplayer.onError(d.message||'Error');" +
            "}else if(d.type==='multiplayer_state'&&window.VibeMultiplayer.onStateReceived){" +
              'window.VibeMultiplayer.onStateReceived(d.state,d.fromPlayerId);' +
            "}else if(d.type==='multiplayer_input'&&window.VibeMultiplayer.onInputReceived){" +
              'window.VibeMultiplayer.onInputReceived(d.input,d.fromPlayerId,d.fromPlayerName);' +
            "}else if(d.type==='multiplayer_player_joined'&&window.VibeMultiplayer.onPlayerJoined){" +
              'window.VibeMultiplayer.players=d.players||[];' +
              'window.VibeMultiplayer.onPlayerJoined(d.players);' +
            "}else if(d.type==='multiplayer_player_left'&&window.VibeMultiplayer.onPlayerLeft){" +
              'window.VibeMultiplayer.players=d.players||[];' +
              'window.VibeMultiplayer.onPlayerLeft(d.players);' +
            "}else if(d.type==='mp_host_changed'){" +
              'window.VibeMultiplayer.players=d.players||window.VibeMultiplayer.players;' +
              'if(window.VibeMultiplayer.onPlayerJoined)window.VibeMultiplayer.onPlayerJoined(window.VibeMultiplayer.players);' +
            '}' +
          '});' +
          "console.log('\\uD83C\\uDFAE Vibe Multiplayer API ready (pre-injected). Player: '+window.VibeMultiplayer.playerId);" +
          '})();' +
        '</scr' + 'ipt>';

        const headMatch = codeToWrite.match(/<head[^>]*>/i);
        if (headMatch) {
          const insertPos = headMatch.index + headMatch[0].length;
          codeToWrite = codeToWrite.slice(0, insertPos) + mpBootstrap + codeToWrite.slice(insertPos);
        } else {
          codeToWrite = mpBootstrap + codeToWrite;
        }
      }

      // Inject responsive overrides into the HTML string
      const responsiveStyle = '<style>html,body{max-width:100vw!important;overflow-x:hidden!important}body>*{max-width:100vw!important;box-sizing:border-box!important}canvas{max-width:100%!important;height:auto!important}table{max-width:100%!important}</style>';
      const headTag = codeToWrite.match(/<head[^>]*>/i);
      if (headTag) {
        const pos = headTag.index + headTag[0].length;
        codeToWrite = codeToWrite.slice(0, pos) + responsiveStyle + codeToWrite.slice(pos);
      } else {
        codeToWrite = responsiveStyle + codeToWrite;
      }

      // Use srcdoc for clean document loading (no about:blank race condition,
      // no re-declaration errors on refresh ‚Äî each srcdoc is a fresh document)
      iframe.srcdoc = codeToWrite;

      // After iframe loads, inject viewport meta and (if needed) multiplayer helper
      iframe.onload = function() {
        try {
          const doc = iframe.contentDocument;
          if (doc && !doc.querySelector('meta[name="viewport"]')) {
            const meta = doc.createElement('meta');
            meta.name = 'viewport';
            meta.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no';
            doc.head.appendChild(meta);
          }
        } catch (e) { /* cross-origin safety */ }

        // Multiplayer API is pre-injected into srcdoc HTML, so we do NOT call
        // injectMultiplayerHelper() here ‚Äî that would replace the VibeMultiplayer
        // object and wipe out callbacks the game already registered.
      };
      
      // Focus iframe so arrow keys reach the game (click game area to play)
      iframe.setAttribute('tabindex', '0');
      setTimeout(function() {
        try { iframe.focus(); } catch (e) { /* ignore */ }
      }, 100);
      
      // Hide loading, show play container
      document.getElementById('loading').style.display = 'none';
      document.getElementById('play').style.display = 'flex';
    }
    
    // Show error
    function showError() {
      document.getElementById('loading').style.display = 'none';
      document.getElementById('error').style.display = 'flex';
    }
    
    // Get/set liked projects (localStorage - one like per browser per project)
    const LIKED_KEY = 'vck_liked_projects';
    function getLikedProjects() {
      try {
        const raw = localStorage.getItem(LIKED_KEY);
        return raw ? JSON.parse(raw) : [];
      } catch { return []; }
    }
    function setLiked(id, liked) {
      const ids = getLikedProjects();
      const idx = ids.indexOf(id);
      if (liked && idx === -1) ids.push(id);
      else if (!liked && idx !== -1) ids.splice(idx, 1);
      localStorage.setItem(LIKED_KEY, JSON.stringify(ids));
    }
    function hasLiked(id) {
      return getLikedProjects().includes(id);
    }

    // Update like button UI
    function updateLikeButton() {
      if (!currentProject) return;
      const btn = document.querySelector('.action-btn.like');
      if (!btn) return;
      const liked = hasLiked(currentProject.id);
      const emojiSpan = btn.querySelector('.btn-emoji');
      btn.disabled = false;
      if (liked) {
        if (emojiSpan) emojiSpan.textContent = '‚ù§Ô∏è';
        btn.innerHTML = '<span class="btn-emoji">‚ù§Ô∏è</span> Liked!';
      } else {
        if (emojiSpan) emojiSpan.textContent = '‚ù§Ô∏è';
        btn.innerHTML = '<span class="btn-emoji">‚ù§Ô∏è</span> Like';
      }
    }

    // Like project (toggle: like if not liked, unlike if already liked)
    async function likeProject(event) {
      if (!currentProject) return;
      const btn = event.target.closest('.action-btn');
      if (!btn || btn.disabled) return;

      const alreadyLiked = hasLiked(currentProject.id);
      const method = alreadyLiked ? 'DELETE' : 'POST';

      try {
        btn.disabled = true;
        const response = await fetch(`/api/projects/${currentProject.id}/like`, { method });
        if (!response.ok) throw new Error('Failed');

        const data = await response.json();
        document.getElementById('likeCount').textContent = data.likes;
        setLiked(currentProject.id, !alreadyLiked);
        updateLikeButton();
      } catch (err) {
        console.error('Error toggling like:', err);
        btn.disabled = false;
      }
    }
    
    // Toggle fullscreen (uses Fullscreen API on mobile for immersive play)
    function toggleFullscreen() {
      const container = document.getElementById('play');
      const isFullscreen = container.classList.contains('fullscreen');

      if (!isFullscreen) {
        container.classList.add('fullscreen');
        if (container.requestFullscreen) {
          container.requestFullscreen().catch(() => {});
        } else if (container.webkitRequestFullscreen) {
          container.webkitRequestFullscreen();
        }
      } else {
        container.classList.remove('fullscreen');
        if (document.exitFullscreen) {
          document.exitFullscreen().catch(() => {});
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        }
      }
    }
    
    // Sync CSS class with native fullscreen exit (Escape key, swipe gesture)
    document.addEventListener('fullscreenchange', () => {
      if (!document.fullscreenElement) {
        document.getElementById('play').classList.remove('fullscreen');
      }
    });
    document.addEventListener('webkitfullscreenchange', () => {
      if (!document.webkitFullscreenElement) {
        document.getElementById('play').classList.remove('fullscreen');
      }
    });
    
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        document.getElementById('play').classList.remove('fullscreen');
      }
    });
    
    // Load on page load
    loadProject();
    
    // ========== MULTIPLAYER FUNCTIONS (game-hosted UI) ==========
    
    // Initialize multiplayer: set flag so VibeMultiplayer is injected when iframe loads
    function initMultiplayer() {
      if (currentProject && currentProject.multiplayer) {
        pendingMultiplayerInject = true;
      }
    }
    
    // Connect to WebSocket server (called when game requests create/join)
    function connectWebSocket(onOpenCallback) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        if (onOpenCallback) onOpenCallback();
        return;
      }
      
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}/ws/multiplayer`;
      
      ws = new WebSocket(wsUrl);

      if (wsConnectTimeout) clearTimeout(wsConnectTimeout);
      wsConnectTimeout = setTimeout(function() {
        if (ws && ws.readyState !== WebSocket.OPEN) {
          ws.close();
          ws = null;
          sendToGame({ type: 'mp_error', message: 'Could not connect to the game server. Please try again.' });
        }
      }, 8000);
      
      ws.onopen = () => {
        if (wsConnectTimeout) { clearTimeout(wsConnectTimeout); wsConnectTimeout = null; }
        startPingInterval();
        if (onOpenCallback) onOpenCallback();
      };
      
      ws.onmessage = (event) => {
        let message;
        try {
          message = JSON.parse(event.data);
        } catch (err) {
          console.error('Failed to parse WebSocket message:', err);
          return;
        }
        handleWebSocketMessage(message);
      };
      
      ws.onclose = () => {
        if (wsConnectTimeout) { clearTimeout(wsConnectTimeout); wsConnectTimeout = null; }
        ws = null;
        stopPingInterval();
        currentRoomCode = null;
        players = [];
      };
      
      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        sendToGame({ type: 'mp_error', message: 'Connection error. Please try again.' });
      };
    }
    
    // Handle incoming WebSocket messages
    function handleWebSocketMessage(message) {
      switch (message.type) {
        case 'welcome':
          myPlayerId = message.playerId;
          break;
          
        case 'room_created':
          currentRoomCode = message.roomCode;
          players = message.players;
          sendToGame({ type: 'mp_room_created', roomCode: message.roomCode, players: message.players, playerId: myPlayerId });
          break;
          
        case 'room_joined':
          currentRoomCode = message.roomCode;
          players = message.players;
          sendToGame({ type: 'mp_room_joined', roomCode: message.roomCode, players: message.players, playerId: myPlayerId });
          break;
          
        case 'player_joined':
          players = message.players;
          sendToGame({ type: 'multiplayer_player_joined', players: players });
          break;
          
        case 'player_left':
          players = message.players;
          sendToGame({ type: 'multiplayer_player_left', players: players });
          break;
          
        case 'host_changed':
          players = players.map(p => ({ ...p, isHost: p.id === message.newHostId }));
          sendToGame({ type: 'mp_host_changed', newHostName: message.newHostName, players: players });
          break;
          
        case 'room_left':
          currentRoomCode = null;
          players = [];
          sendToGame({ type: 'mp_room_left' });
          break;
          
        case 'game_state':
          sendToGame({
            type: 'multiplayer_state',
            state: message.state,
            fromPlayerId: message.fromPlayerId
          });
          break;
          
        case 'player_input':
          sendToGame({
            type: 'multiplayer_input',
            input: message.input,
            fromPlayerId: message.fromPlayerId,
            fromPlayerName: message.fromPlayerName
          });
          break;
          
        case 'error':
          sendToGame({ type: 'mp_error', message: message.message || 'Something went wrong. Please try again.' });
          break;
          
        case 'pong':
          break;
      }
    }
    
    // Handle create/join/leave from game (via postMessage)
    function handleGameMultiplayerRequest(data) {
      if (data.type === 'mp_create_room') {
        const name = (data.playerName || '').toString().trim().slice(0, 20) || 'Player';
        localStorage.setItem('playerName', name);
        pendingCreateRoom = { playerName: name };
        connectWebSocket(function() {
          if (ws && ws.readyState === WebSocket.OPEN && pendingCreateRoom) {
            ws.send(JSON.stringify({
              type: 'create_room',
              projectId: currentProject.id,
              playerName: pendingCreateRoom.playerName
            }));
            pendingCreateRoom = null;
          }
        });
        return;
      }
      if (data.type === 'mp_join_room') {
        const name = (data.playerName || '').toString().trim().slice(0, 20) || 'Player';
        const code = (data.roomCode || '').toString().trim().replace(/[^A-Za-z0-9]/g, '').toUpperCase().slice(0, 4);
        localStorage.setItem('playerName', name);
        if (!code || code.length !== 4) {
          sendToGame({ type: 'mp_error', message: 'Please enter a valid 4-character room code.' });
          return;
        }
        pendingJoinRoom = { roomCode: code, playerName: name };
        connectWebSocket(function() {
          if (ws && ws.readyState === WebSocket.OPEN && pendingJoinRoom) {
            ws.send(JSON.stringify({
              type: 'join_room',
              roomCode: pendingJoinRoom.roomCode,
              playerName: pendingJoinRoom.playerName
            }));
            pendingJoinRoom = null;
          }
        });
        return;
      }
      if (data.type === 'mp_leave_room') {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'leave_room' }));
        }
        currentRoomCode = null;
        players = [];
        return;
      }
    }
    
    // Inject multiplayer helper into iframe
    function injectMultiplayerHelper(retries) {
      retries = retries || 0;
      const iframe = document.getElementById('projectIframe');
      if (!iframe || !iframe.contentWindow) return;
      
      try {
        if (!iframe.contentDocument || !iframe.contentDocument.body) {
          if (retries < 15) {
            setTimeout(function() { injectMultiplayerHelper(retries + 1); }, 300);
          } else {
            console.error('Multiplayer inject: gave up after 15 retries (no body)');
          }
          return;
        }

        const script = iframe.contentDocument.createElement('script');
        const roomCodeJson = JSON.stringify(currentRoomCode || null);
        const playersJson = JSON.stringify(players).replace(/<\/script>/gi, '<\\/script>');
        const playerIdEsc = (myPlayerId || '').replace(/\\/g, '\\\\').replace(/'/g, "\\'");
        script.textContent = `
          (function() {
            window.VibeMultiplayer = {
              roomCode: ${roomCodeJson},
              playerId: '${playerIdEsc}',
              players: ${playersJson},
              createRoom: function(playerName) {
                window.parent.postMessage({ type: 'mp_create_room', playerName: (playerName || 'Player').toString().trim().slice(0, 20) || 'Player' }, '*');
              },
              joinRoom: function(code, playerName) {
                window.parent.postMessage({ type: 'mp_join_room', roomCode: String(code || ''), playerName: (playerName || 'Player').toString().trim().slice(0, 20) || 'Player' }, '*');
              },
              leaveRoom: function() {
                window.parent.postMessage({ type: 'mp_leave_room' }, '*');
              },
              sendState: function(state) {
                window.parent.postMessage({ type: 'mp_state', state: state }, '*');
              },
              sendInput: function(input) {
                window.parent.postMessage({ type: 'mp_input', input: input }, '*');
              },
              onRoomCreated: null,
              onRoomJoined: null,
              onRoomLeft: null,
              onError: null,
              onStateReceived: null,
              onInputReceived: null,
              onPlayerJoined: null,
              onPlayerLeft: null
            };
            window.addEventListener('message', function(event) {
              var d = event.data;
              if (d.type === 'mp_room_created') {
                if (d.playerId) window.VibeMultiplayer.playerId = d.playerId;
                window.VibeMultiplayer.roomCode = d.roomCode;
                window.VibeMultiplayer.players = d.players || [];
                if (window.VibeMultiplayer.onRoomCreated) window.VibeMultiplayer.onRoomCreated(d.roomCode, d.players);
              } else if (d.type === 'mp_room_joined') {
                if (d.playerId) window.VibeMultiplayer.playerId = d.playerId;
                window.VibeMultiplayer.roomCode = d.roomCode;
                window.VibeMultiplayer.players = d.players || [];
                if (window.VibeMultiplayer.onRoomJoined) window.VibeMultiplayer.onRoomJoined(d.roomCode, d.players);
              } else if (d.type === 'mp_room_left') {
                window.VibeMultiplayer.roomCode = null;
                window.VibeMultiplayer.players = [];
                if (window.VibeMultiplayer.onRoomLeft) window.VibeMultiplayer.onRoomLeft();
              } else if (d.type === 'mp_error') {
                if (window.VibeMultiplayer.onError) window.VibeMultiplayer.onError(d.message || 'Error');
              } else if (d.type === 'multiplayer_state' && window.VibeMultiplayer.onStateReceived) {
                window.VibeMultiplayer.onStateReceived(d.state, d.fromPlayerId);
              } else if (d.type === 'multiplayer_input' && window.VibeMultiplayer.onInputReceived) {
                window.VibeMultiplayer.onInputReceived(d.input, d.fromPlayerId, d.fromPlayerName);
              } else if (d.type === 'multiplayer_player_joined' && window.VibeMultiplayer.onPlayerJoined) {
                window.VibeMultiplayer.players = d.players || [];
                window.VibeMultiplayer.onPlayerJoined(d.players);
              } else if (d.type === 'multiplayer_player_left' && window.VibeMultiplayer.onPlayerLeft) {
                window.VibeMultiplayer.players = d.players || [];
                window.VibeMultiplayer.onPlayerLeft(d.players);
              } else if (d.type === 'mp_host_changed') {
                window.VibeMultiplayer.players = d.players || window.VibeMultiplayer.players;
                if (window.VibeMultiplayer.onPlayerJoined) window.VibeMultiplayer.onPlayerJoined(window.VibeMultiplayer.players);
              }
            });
            console.log('üéÆ Vibe Multiplayer API ready (game-hosted). Player: ' + window.VibeMultiplayer.playerId);
          })();
        `;
        iframe.contentDocument.body.appendChild(script);
      } catch (e) {
        console.error('Multiplayer inject:', e);
        if (retries < 15) {
          setTimeout(function() { injectMultiplayerHelper(retries + 1); }, 300);
        }
      }
    }
    
    // Send message to game iframe
    function sendToGame(message) {
      const iframe = document.getElementById('projectIframe');
      if (iframe && iframe.contentWindow) {
        iframe.contentWindow.postMessage(message, '*');
      }
    }
    
    // Listen for messages from game iframe
    window.addEventListener('message', function(event) {
      const data = event.data;
      if (data.type === 'mp_create_room' || data.type === 'mp_join_room' || data.type === 'mp_leave_room') {
        handleGameMultiplayerRequest(data);
        return;
      }
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      
      if (data.type === 'mp_state') {
        ws.send(JSON.stringify({ type: 'game_state', state: data.state }));
      }
      if (data.type === 'mp_input') {
        ws.send(JSON.stringify({ type: 'player_input', input: data.input }));
      }
    });
    
    // Keep WebSocket alive with ping
    let pingIntervalId = null;
    function startPingInterval() {
      stopPingInterval();
      pingIntervalId = setInterval(() => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'ping' }));
        }
      }, 30000);
    }
    function stopPingInterval() {
      if (pingIntervalId !== null) {
        clearInterval(pingIntervalId);
        pingIntervalId = null;
      }
    }
  </script>
</body>
</html>
