<!DOCTYPE html>
<html>
<head>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: linear-gradient(135deg, #1a472a 0%, #2d6a4f 50%, #1a472a 100%);
      min-height: 100vh; display: flex; align-items: center; justify-content: center;
      font-family: 'Segoe UI', sans-serif;
    }
    #game { border-radius: 12px; overflow: hidden; box-shadow: 0 8px 32px rgba(0,0,0,0.5); }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.86.0/dist/phaser.min.js"></script>
</head>
<body>
<div id="game"></div>
<script>
const COLS = 16, ROWS = 10, CELL = 50;
const W = COLS * CELL, H = ROWS * CELL;

class Frog extends Phaser.Scene {
  constructor() { super('Frog'); }

  create() {
    this.score = 0; this.lives = 3; this.round = 1; this.moving = false;
    if (!this.textures.exists('frog')) {
      const g = this.make.graphics({ add: false });
      g.fillStyle(0x44cc44); g.fillCircle(12, 14, 12);
      g.fillStyle(0x228822); g.fillCircle(6, 8, 4); g.fillCircle(18, 8, 4);
      g.fillStyle(0xffffff); g.fillCircle(6, 7, 2); g.fillCircle(18, 7, 2);
      g.generateTexture('frog', 26, 26); g.destroy();
      const c = this.make.graphics({ add: false });
      c.fillStyle(0xdd3333); c.fillRect(0, 0, 60, 28); c.fillStyle(0xffcc00); c.fillRect(2, 10, 8, 8);
      c.generateTexture('car1', 60, 28); c.destroy();
      const c2 = this.make.graphics({ add: false });
      c2.fillStyle(0x3355dd); c2.fillRect(0, 0, 50, 26); c2.fillStyle(0xaaddff); c2.fillRect(8, 4, 34, 10);
      c2.generateTexture('car2', 50, 26); c2.destroy();
      const c3 = this.make.graphics({ add: false });
      c3.fillStyle(0xff8800); c3.fillRect(0, 0, 80, 30); c3.fillStyle(0xffdd00); c3.fillRect(2, 2, 10, 10);
      c3.generateTexture('truck', 80, 30); c3.destroy();
    }

    this.add.rectangle(W / 2, H / 2, W, H, 0x555555);
    [0, 4, ROWS - 1].forEach(r => this.add.rectangle(W / 2, r * CELL + CELL / 2, W, CELL, 0x44aa44));
    for (let r = 0; r < ROWS; r++) {
      if (r === 0 || r === 4 || r === ROWS - 1) continue;
      for (let x = 0; x < W; x += CELL * 2) {
        this.add.rectangle(x + 10, r * CELL + CELL / 2, 6, 12, 0xffffff).setAlpha(0.3);
      }
    }

    this.player = this.physics.add.sprite(W / 2, (ROWS - 1) * CELL + CELL / 2, 'frog');
    this.player.setCollideWorldBounds(true).setDepth(10);

    this.obstacles = this.physics.add.group();
    this.laneConfig = [
      { row: 1, speed: 100, dir: 1, tex: 'car1', count: 3 },
      { row: 2, speed: 130, dir: -1, tex: 'car2', count: 3 },
      { row: 3, speed: 90, dir: 1, tex: 'truck', count: 2 },
      { row: 5, speed: 140, dir: -1, tex: 'car1', count: 3 },
      { row: 6, speed: 110, dir: 1, tex: 'car2', count: 4 },
      { row: 7, speed: 160, dir: -1, tex: 'truck', count: 2 },
      { row: 8, speed: 120, dir: 1, tex: 'car1', count: 3 },
    ];
    this.spawnObstacles();
    this.physics.add.overlap(this.player, this.obstacles, this.hitCar, null, this);

    this.cursors = this.input.keyboard.createCursorKeys();
    this.scoreText = this.add.text(10, 6, 'Score: 0', { fontSize: '18px', fill: '#fff', stroke: '#000', strokeThickness: 3 }).setDepth(20);
    this.livesText = this.add.text(W - 10, 6, 'Lives: 3', { fontSize: '18px', fill: '#ff6666', stroke: '#000', strokeThickness: 3 }).setOrigin(1, 0).setDepth(20);
    this.gameOver = false;
  }

  spawnObstacles() {
    this.obstacles.clear(true, true);
    this.laneConfig.forEach(lane => {
      const spacing = W / lane.count;
      for (let i = 0; i < lane.count; i++) {
        const ob = this.obstacles.create(spacing * i + spacing / 2, lane.row * CELL + CELL / 2, lane.tex);
        ob.setVelocityX(lane.speed * lane.dir * (1 + (this.round - 1) * 0.15));
        ob.body.setAllowGravity(false);
        ob.laneDir = lane.dir;
      }
    });
  }

  hitCar() {
    if (this.gameOver) return;
    this.lives--;
    this.livesText.setText('Lives: ' + this.lives);
    if (this.lives <= 0) {
      this.gameOver = true;
      this.physics.pause();
      this.add.text(W / 2, H / 2, 'GAME OVER\nScore: ' + this.score + '\nPress SPACE', { fontSize: '28px', fill: '#fff', stroke: '#000', strokeThickness: 4, align: 'center' }).setOrigin(0.5).setDepth(30);
      this.input.keyboard.once('keydown-SPACE', () => this.scene.restart());
    } else {
      this.resetPlayer();
    }
  }

  resetPlayer() {
    this.player.setPosition(W / 2, (ROWS - 1) * CELL + CELL / 2);
    this.player.setAlpha(0.5);
    this.time.delayedCall(500, () => this.player.setAlpha(1));
    this.moving = false;
  }

  update() {
    if (this.gameOver || this.moving) return;
    let dx = 0, dy = 0;
    if (Phaser.Input.Keyboard.JustDown(this.cursors.left)) dx = -CELL;
    else if (Phaser.Input.Keyboard.JustDown(this.cursors.right)) dx = CELL;
    else if (Phaser.Input.Keyboard.JustDown(this.cursors.up)) dy = -CELL;
    else if (Phaser.Input.Keyboard.JustDown(this.cursors.down)) dy = CELL;

    if (dx !== 0 || dy !== 0) {
      const nx = Phaser.Math.Clamp(this.player.x + dx, CELL / 2, W - CELL / 2);
      const ny = Phaser.Math.Clamp(this.player.y + dy, CELL / 2, H - CELL / 2);
      this.moving = true;
      this.tweens.add({
        targets: this.player, x: nx, y: ny, duration: 120, ease: 'Quad.easeOut',
        onComplete: () => {
          this.moving = false;
          if (this.player.y <= CELL / 2 + 5) {
            this.score += 100 * this.round;
            this.scoreText.setText('Score: ' + this.score);
            this.round++;
            this.resetPlayer();
            this.spawnObstacles();
          }
        }
      });
    }

    this.obstacles.children.each(ob => {
      if (ob.laneDir > 0 && ob.x > W + 50) ob.x = -50;
      else if (ob.laneDir < 0 && ob.x < -50) ob.x = W + 50;
    });
  }
}

new Phaser.Game({
  type: Phaser.AUTO, width: W, height: H, parent: 'game',
  backgroundColor: '#555555',
  physics: { default: 'arcade', arcade: { gravity: { y: 0 }, debug: false } },
  scene: Frog
});
</script>
</body>
</html>
