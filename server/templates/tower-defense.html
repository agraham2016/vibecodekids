<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    :root {
      --game-primary: #00b894;
      --game-secondary: #636e72;
      --game-bg: #2d3436;
      --game-text: #ffffff;
      --game-accent: #00b894;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #2d3436 0%, #636e72 50%, #00b894 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
     touch-action: none; }
    #game-container {
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    }
  </style>
</head>
<body>
  <div id="game-container"></div>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.86.0/dist/phaser.min.js"></script>
  <script>
  class TowerDefenseScene extends Phaser.Scene {
    preload() {
      this.load.image('tower', '/assets/sprites/tower-defense/tower.png');
      this.load.image('enemy', '/assets/sprites/tower-defense/enemy.png');
      this.load.image('bullet', '/assets/sprites/tower-defense/bullet.png');
      this.load.image('path', '/assets/sprites/tower-defense/path.png');
      this.load.image('particle', '/assets/sprites/common/particle.png');
      this.load.audio('hitSfx', '/assets/sounds/hit.wav');
      this.load.audio('explosionSfx', '/assets/sounds/explosion.wav');
      this.load.audio('coinSfx', '/assets/sounds/coin.wav');
    }

    create() {
      const g = this.make.graphics({ add: false });

      if (!this.textures.exists('tower') || this.textures.get('tower').key === '__MISSING') {
        g.fillStyle(0x636e72); g.fillRect(4, 4, 32, 32);
        g.fillStyle(0x00b894); g.fillRect(8, 8, 24, 24);
        g.fillStyle(0x00cec9); g.fillRect(14, 2, 12, 8);
        g.fillStyle(0x55efc4); g.fillCircle(20, 20, 6);
        g.fillStyle(0x2d3436); g.fillCircle(20, 20, 3);
        g.generateTexture('tower', 40, 40); g.clear();
      }
      if (!this.textures.exists('enemy') || this.textures.get('enemy').key === '__MISSING') {
        g.fillStyle(0xe74c3c); g.fillCircle(12, 12, 12);
        g.fillStyle(0xc0392b); g.fillCircle(12, 12, 8);
        g.fillStyle(0xff7675); g.fillCircle(10, 9, 3);
        g.generateTexture('enemy', 24, 24); g.clear();
      }
      if (!this.textures.exists('bullet') || this.textures.get('bullet').key === '__MISSING') {
        g.fillStyle(0x00b894); g.fillCircle(4, 4, 4);
        g.fillStyle(0x55efc4); g.fillCircle(3, 3, 2);
        g.generateTexture('bullet', 8, 8); g.clear();
      }
      if (!this.textures.exists('path') || this.textures.get('path').key === '__MISSING') {
        g.fillStyle(0x6c5ce7, 0.15); g.fillRect(0, 0, 40, 40);
        g.lineStyle(1, 0x6c5ce7, 0.3); g.strokeRect(0, 0, 40, 40);
        g.generateTexture('path', 40, 40); g.clear();
      }
      if (!this.textures.exists('particle') || this.textures.get('particle').key === '__MISSING') {
        g.fillStyle(0xffffff); g.fillCircle(4, 4, 4);
        g.generateTexture('particle', 8, 8); g.clear();
      }
      g.destroy();

      this.CELL = 40;
      this.COLS = 20;
      this.ROWS = 12;
      this.money = 100;
      this.lives = 20;
      this.wave = 0;
      this.waveActive = false;
      this.gameOver = false;
      this.enemiesAlive = 0;
      this.enemiesSpawned = 0;
      this.enemiesToSpawn = 0;
      this.towerCost = 25;
      this.towers = [];

      this.pathPoints = [
        { x: 0, y: 5 },
        { x: 4, y: 5 },
        { x: 4, y: 2 },
        { x: 8, y: 2 },
        { x: 8, y: 8 },
        { x: 12, y: 8 },
        { x: 12, y: 3 },
        { x: 16, y: 3 },
        { x: 16, y: 9 },
        { x: 19, y: 9 }
      ];

      this.pathCells = new Set();
      for (let i = 0; i < this.pathPoints.length - 1; i++) {
        const a = this.pathPoints[i];
        const b = this.pathPoints[i + 1];
        if (a.x === b.x) {
          const minY = Math.min(a.y, b.y);
          const maxY = Math.max(a.y, b.y);
          for (let y = minY; y <= maxY; y++) this.pathCells.add(a.x + ',' + y);
        } else {
          const minX = Math.min(a.x, b.x);
          const maxX = Math.max(a.x, b.x);
          for (let x = minX; x <= maxX; x++) this.pathCells.add(x + ',' + a.y);
        }
      }

      this.pixelPath = [];
      for (let i = 0; i < this.pathPoints.length; i++) {
        this.pixelPath.push({
          x: this.pathPoints[i].x * this.CELL + this.CELL / 2,
          y: this.pathPoints[i].y * this.CELL + this.CELL / 2 + this.CELL
        });
      }

      this.drawBackground();

      this.enemies = this.physics.add.group();
      this.bullets = this.physics.add.group();

      this.hitEmitter = this.add.particles(0, 0, 'particle', {
        speed: { min: 60, max: 160 },
        lifespan: 250,
        scale: { start: 1, end: 0 },
        emitting: false,
        quantity: 8,
        tint: [0xe74c3c, 0xff7675, 0xfab1a0]
      });

      this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);

      const panelY = 0;
      this.uiPanel = this.add.rectangle(400, panelY + 20, 800, 40, 0x2d3436, 0.85).setDepth(20);

      const ts = { fontFamily: 'Segoe UI', fontSize: '16px', stroke: '#2d3436', strokeThickness: 2 };
      this.moneyText = this.add.text(16, panelY + 12, '$' + this.money, {
        ...ts, fill: '#ffd700',
        shadow: { offsetX: 0, offsetY: 0, color: '#ffd700', blur: 6, fill: true }
      }).setDepth(21);

      this.livesText = this.add.text(160, panelY + 12, 'Lives: ' + this.lives, {
        ...ts, fill: '#ff7675',
        shadow: { offsetX: 0, offsetY: 0, color: '#ff7675', blur: 6, fill: true }
      }).setDepth(21);

      this.waveText = this.add.text(400, panelY + 12, 'Click START to begin', {
        ...ts, fontSize: '15px', fill: '#00b894',
        shadow: { offsetX: 0, offsetY: 0, color: '#00b894', blur: 6, fill: true }
      }).setOrigin(0.5, 0).setDepth(21);

      this.costText = this.add.text(784, panelY + 12, 'Tower: $' + this.towerCost, {
        ...ts, fill: '#55efc4'
      }).setOrigin(1, 0).setDepth(21);

      this.startBtn = this.add.text(680, panelY + 12, '[START]', {
        ...ts, fill: '#fdcb6e', fontStyle: 'bold'
      }).setDepth(21).setInteractive({ useHandCursor: true });
      this.startBtn.on('pointerdown', () => this.startWave());
      this.startBtn.on('pointerover', () => this.startBtn.setFill('#fff'));
      this.startBtn.on('pointerout', () => this.startBtn.setFill('#fdcb6e'));

      this.placementPreview = this.add.rectangle(0, 0, this.CELL - 4, this.CELL - 4, 0x00b894, 0.3)
        .setStrokeStyle(2, 0x00b894, 0.6).setDepth(15).setVisible(false);

      this.input.on('pointermove', (pointer) => {
        if (this.gameOver) return;
        const col = Math.floor(pointer.x / this.CELL);
        const row = Math.floor((pointer.y - this.CELL) / this.CELL);
        if (row < 0 || row >= this.ROWS || col < 0 || col >= this.COLS) {
          this.placementPreview.setVisible(false);
          return;
        }
        const key = col + ',' + row;
        const canPlace = !this.pathCells.has(key) && !this.towerAt(col, row) && this.money >= this.towerCost;
        this.placementPreview.setPosition(col * this.CELL + this.CELL / 2, row * this.CELL + this.CELL / 2 + this.CELL);
        this.placementPreview.setFillStyle(canPlace ? 0x00b894 : 0xe74c3c, 0.3);
        this.placementPreview.setStrokeStyle(2, canPlace ? 0x00b894 : 0xe74c3c, 0.6);
        this.placementPreview.setVisible(true);
      });

      this.input.on('pointerdown', (pointer) => {
        if (this.gameOver) return;
        const col = Math.floor(pointer.x / this.CELL);
        const row = Math.floor((pointer.y - this.CELL) / this.CELL);
        if (row < 0 || row >= this.ROWS || col < 0 || col >= this.COLS) return;
        this.placeTower(col, row);
      });
    }

    drawBackground() {
      const bg = this.add.graphics();
      bg.fillStyle(0x2d3436); bg.fillRect(0, 0, 800, 520);

      for (let c = 0; c < this.COLS; c++) {
        for (let r = 0; r < this.ROWS; r++) {
          const shade = (c + r) % 2 === 0 ? 0x353b48 : 0x2d3436;
          bg.fillStyle(shade);
          bg.fillRect(c * this.CELL, r * this.CELL + this.CELL, this.CELL, this.CELL);
        }
      }

      bg.lineStyle(1, 0x636e72, 0.15);
      for (let c = 0; c <= this.COLS; c++) bg.lineBetween(c * this.CELL, this.CELL, c * this.CELL, this.ROWS * this.CELL + this.CELL);
      for (let r = 0; r <= this.ROWS; r++) bg.lineBetween(0, r * this.CELL + this.CELL, this.COLS * this.CELL, r * this.CELL + this.CELL);

      const pathG = this.add.graphics();
      pathG.lineStyle(this.CELL * 0.8, 0x6c5ce7, 0.25);
      pathG.beginPath();
      pathG.moveTo(this.pixelPath[0].x, this.pixelPath[0].y);
      for (let i = 1; i < this.pixelPath.length; i++) {
        pathG.lineTo(this.pixelPath[i].x, this.pixelPath[i].y);
      }
      pathG.strokePath();

      pathG.lineStyle(this.CELL * 0.5, 0x6c5ce7, 0.15);
      pathG.beginPath();
      pathG.moveTo(this.pixelPath[0].x, this.pixelPath[0].y);
      for (let i = 1; i < this.pixelPath.length; i++) {
        pathG.lineTo(this.pixelPath[i].x, this.pixelPath[i].y);
      }
      pathG.strokePath();

      for (let i = 0; i < this.pixelPath.length - 1; i++) {
        const a = this.pixelPath[i];
        const b = this.pixelPath[i + 1];
        const dist = Phaser.Math.Distance.Between(a.x, a.y, b.x, b.y);
        const steps = Math.floor(dist / 30);
        for (let s = 0; s < steps; s++) {
          const t = s / steps;
          const x = a.x + (b.x - a.x) * t;
          const y = a.y + (b.y - a.y) * t;
          const angle = Math.atan2(b.y - a.y, b.x - a.x);
          pathG.fillStyle(0x6c5ce7, 0.3);
          pathG.fillTriangle(
            x + Math.cos(angle) * 6, y + Math.sin(angle) * 6,
            x + Math.cos(angle + 2.5) * 4, y + Math.sin(angle + 2.5) * 4,
            x + Math.cos(angle - 2.5) * 4, y + Math.sin(angle - 2.5) * 4
          );
        }
      }

      const startX = this.pixelPath[0].x;
      const startY = this.pixelPath[0].y;
      const endX = this.pixelPath[this.pixelPath.length - 1].x;
      const endY = this.pixelPath[this.pixelPath.length - 1].y;

      pathG.fillStyle(0x00b894, 0.6);
      pathG.fillCircle(startX, startY, 10);
      pathG.fillStyle(0xe74c3c, 0.6);
      pathG.fillCircle(endX, endY, 10);
    }

    towerAt(col, row) {
      return this.towers.some(t => t.col === col && t.row === row);
    }

    placeTower(col, row) {
      const key = col + ',' + row;
      if (this.pathCells.has(key) || this.towerAt(col, row) || this.money < this.towerCost) return;

      this.money -= this.towerCost;
      this.moneyText.setText('$' + this.money);

      const x = col * this.CELL + this.CELL / 2;
      const y = row * this.CELL + this.CELL / 2 + this.CELL;

      const sprite = this.add.image(x, y, 'tower').setDepth(5);
      sprite.setScale(0);
      this.tweens.add({ targets: sprite, scale: 1, duration: 200, ease: 'Back.easeOut' });

      const rangeCircle = this.add.circle(x, y, 120, 0x00b894, 0.05)
        .setStrokeStyle(1, 0x00b894, 0.15).setDepth(4);

      const tower = {
        col, row, x, y, sprite, rangeCircle,
        range: 120,
        fireRate: 800,
        damage: 10,
        lastFired: 0
      };
      this.towers.push(tower);

      if (this.cache.audio.exists('coinSfx')) this.sound.play('coinSfx');
    }

    startWave() {
      if (this.waveActive || this.gameOver) return;
      this.wave++;
      this.waveActive = true;
      this.enemiesSpawned = 0;
      this.enemiesToSpawn = 5 + this.wave * 3;
      this.enemiesAlive = 0;
      this.waveText.setText('Wave ' + this.wave);
      this.startBtn.setVisible(false);

      const spawnDelay = Math.max(300, 900 - this.wave * 40);
      this.spawnTimer = this.time.addEvent({
        delay: spawnDelay,
        callback: this.spawnEnemy,
        callbackScope: this,
        repeat: this.enemiesToSpawn - 1
      });
    }

    spawnEnemy() {
      if (this.gameOver) return;
      this.enemiesSpawned++;
      this.enemiesAlive++;

      const hp = 30 + this.wave * 15;
      const speed = 50 + this.wave * 5;
      const isBoss = this.enemiesSpawned === this.enemiesToSpawn && this.wave % 3 === 0;

      const e = this.enemies.create(this.pixelPath[0].x, this.pixelPath[0].y, 'enemy').setDepth(6);
      e.hp = isBoss ? hp * 3 : hp;
      e.maxHp = e.hp;
      e.speed = isBoss ? speed * 0.6 : speed;
      e.pathIndex = 0;
      e.reward = isBoss ? 30 : 10;
      e.body.allowGravity = false;

      if (isBoss) {
        e.setScale(1.8);
        e.setTint(0x6c5ce7);
      }

      const hpBarBg = this.add.rectangle(e.x, e.y - 16, 22, 4, 0x2d3436).setDepth(7);
      const hpBar = this.add.rectangle(e.x, e.y - 16, 20, 2, 0x00b894).setDepth(8);
      e.hpBarBg = hpBarBg;
      e.hpBar = hpBar;
    }

    bulletHitEnemy(bullet, enemy) {
      if (!enemy.active || !bullet.active) return;
      const dmg = bullet.damage || 10;
      enemy.hp -= dmg;
      bullet.destroy();

      this.hitEmitter.emitParticleAt(enemy.x, enemy.y);

      if (enemy.hp <= 0) {
        this.enemyKilled(enemy);
      } else {
        const pct = Math.max(0, enemy.hp / enemy.maxHp);
        if (enemy.hpBar) {
          enemy.hpBar.width = 20 * pct;
          enemy.hpBar.fillColor = pct > 0.5 ? 0x00b894 : pct > 0.25 ? 0xfdcb6e : 0xe74c3c;
        }
        enemy.setTintFill(0xffffff);
        this.time.delayedCall(60, () => { if (enemy.active) enemy.clearTint(); });
      }
    }

    enemyKilled(enemy) {
      if (this.cache.audio.exists('explosionSfx')) this.sound.play('explosionSfx');
      this.hitEmitter.emitParticleAt(enemy.x, enemy.y);

      this.money += enemy.reward;
      this.moneyText.setText('$' + this.money);

      const txt = this.add.text(enemy.x, enemy.y - 20, '+$' + enemy.reward, {
        fontSize: '14px', fill: '#ffd700', fontFamily: 'Segoe UI', fontStyle: 'bold'
      }).setDepth(15);
      this.tweens.add({
        targets: txt, y: txt.y - 30, alpha: 0, duration: 600,
        onComplete: () => txt.destroy()
      });

      if (enemy.hpBar) enemy.hpBar.destroy();
      if (enemy.hpBarBg) enemy.hpBarBg.destroy();
      enemy.destroy();
      this.enemiesAlive--;
      this.checkWaveComplete();
    }

    enemyReachedEnd(enemy) {
      this.lives--;
      this.livesText.setText('Lives: ' + this.lives);
      if (enemy.hpBar) enemy.hpBar.destroy();
      if (enemy.hpBarBg) enemy.hpBarBg.destroy();
      enemy.destroy();
      this.enemiesAlive--;

      this.cameras.main.shake(200, 0.01);

      if (this.lives <= 0) {
        this.showGameOver();
      } else {
        this.checkWaveComplete();
      }
    }

    checkWaveComplete() {
      if (this.enemiesAlive <= 0 && this.enemiesSpawned >= this.enemiesToSpawn) {
        this.waveActive = false;
        this.waveText.setText('Wave ' + this.wave + ' cleared!');
        this.startBtn.setVisible(true);
        this.startBtn.setText('[NEXT WAVE]');
        this.money += 20 + this.wave * 5;
        this.moneyText.setText('$' + this.money);
      }
    }

    showGameOver() {
      this.gameOver = true;
      this.physics.pause();
      if (this.spawnTimer) this.spawnTimer.remove();

      this.add.rectangle(400, 260, 800, 520, 0x000000, 0.75).setDepth(30);
      this.add.text(400, 180, 'GAME OVER', {
        fontSize: '48px', fill: '#e74c3c', fontFamily: 'Segoe UI', fontStyle: 'bold',
        stroke: '#2d3436', strokeThickness: 4,
        shadow: { offsetX: 0, offsetY: 0, color: '#e74c3c', blur: 16, fill: true }
      }).setOrigin(0.5).setDepth(31);

      this.add.text(400, 240, 'Survived ' + this.wave + ' waves', {
        fontSize: '24px', fill: '#00b894', fontFamily: 'Segoe UI'
      }).setOrigin(0.5).setDepth(31);

      this.add.text(400, 280, 'Towers built: ' + this.towers.length, {
        fontSize: '18px', fill: '#dfe6e9', fontFamily: 'Segoe UI'
      }).setOrigin(0.5).setDepth(31);

      this.add.text(400, 340, 'Click to restart', {
        fontSize: '18px', fill: '#fdcb6e', fontFamily: 'Segoe UI'
      }).setOrigin(0.5).setDepth(31);

      this.input.once('pointerdown', () => this.scene.restart());
    }

    update(time) {
      if (this.gameOver) return;

      this.enemies.children.each(e => {
        if (!e || !e.active) return;

        const target = this.pixelPath[e.pathIndex + 1];
        if (!target) {
          this.enemyReachedEnd(e);
          return;
        }

        const dx = target.x - e.x;
        const dy = target.y - e.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 4) {
          e.pathIndex++;
          if (e.pathIndex >= this.pixelPath.length - 1) {
            this.enemyReachedEnd(e);
            return;
          }
        } else {
          const vx = (dx / dist) * e.speed;
          const vy = (dy / dist) * e.speed;
          e.setVelocity(vx, vy);
        }

        if (e.hpBar) {
          e.hpBar.setPosition(e.x, e.y - 18);
          e.hpBarBg.setPosition(e.x, e.y - 18);
        }
      });

      this.towers.forEach(tower => {
        if (time < tower.lastFired + tower.fireRate) return;

        let closest = null;
        let closestDist = tower.range;

        this.enemies.children.each(e => {
          if (!e || !e.active) return;
          const d = Phaser.Math.Distance.Between(tower.x, tower.y, e.x, e.y);
          if (d < closestDist) {
            closestDist = d;
            closest = e;
          }
        });

        if (closest) {
          tower.lastFired = time;
          const b = this.bullets.create(tower.x, tower.y, 'bullet').setDepth(6);
          b.damage = tower.damage;
          b.body.allowGravity = false;

          const angle = Phaser.Math.Angle.Between(tower.x, tower.y, closest.x, closest.y);
          const speed = 300;
          b.setVelocity(Math.cos(angle) * speed, Math.sin(angle) * speed);
          b.lifespan = 1500;
          b.born = time;

          if (this.cache.audio.exists('hitSfx')) this.sound.play('hitSfx', { volume: 0.3 });
        }
      });

      this.bullets.children.each(b => {
        if (!b || !b.active) return;
        if (time - b.born > b.lifespan || b.x < -20 || b.x > 820 || b.y < -20 || b.y > 540) {
          b.destroy();
        }
      });
    }
  }

  new Phaser.Game({
    type: Phaser.AUTO,
    width: 800,
    height: 520,
    parent: 'game-container',
    backgroundColor: '#2d3436',
    physics: { default: 'arcade', arcade: { gravity: { y: 0 }, debug: false } },
    scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
    scene: TowerDefenseScene
  });
  </script>
</body>
</html>
