<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    :root {
      --game-primary: #d63031;
      --game-secondary: #e17055;
      --game-bg: #2d3436;
      --game-text: #ffffff;
      --game-accent: #fdcb6e;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #d63031 0%, #e17055 50%, #2d3436 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
     touch-action: none; }
    #game-container {
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    }
    .hint { margin-top: 14px; color: rgba(255,255,255,0.55); font-size: 14px; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.86.0/dist/phaser.min.js"></script>
</head>
<body>
  <!-- GAME_TITLE -->Beat 'Em Up<!-- /GAME_TITLE -->
  <!-- PLAYER_CHARACTER -->fighter<!-- /PLAYER_CHARACTER -->
  <!-- OBSTACLES -->enemies<!-- /OBSTACLES -->
  <div id="game-container"></div>
  <div class="hint">Arrow keys to move &bull; SPACE punch &bull; SHIFT kick</div>
  <script>
  class FightScene extends Phaser.Scene {
    preload() {
      this.load.image('fighter', '/assets/sprites/fighting/fighter.png');
      this.load.image('enemy', '/assets/sprites/fighting/enemy.png');
      this.load.image('punch', '/assets/sprites/fighting/punch.png');
      this.load.image('particle', '/assets/sprites/common/particle.png');
      this.load.audio('hitSfx', '/assets/sounds/hit.wav');
      this.load.audio('explosionSfx', '/assets/sounds/explosion.wav');
    }

    create() {
      const g = this.make.graphics({ add: false });

      if (!this.textures.exists('fighter') || this.textures.get('fighter').key === '__MISSING') {
        g.fillStyle(0x2980b9); g.fillRect(4, 0, 24, 14);
        g.fillStyle(0xfad390); g.fillRect(8, 0, 16, 14);
        g.fillStyle(0x2d3436); g.fillRect(12, 4, 3, 3); g.fillRect(19, 4, 3, 3);
        g.fillStyle(0xe17055); g.fillRect(14, 10, 6, 2);
        g.fillStyle(0xd63031); g.fillRect(4, 14, 24, 18);
        g.fillStyle(0xfad390); g.fillRect(0, 16, 6, 4); g.fillRect(26, 16, 6, 4);
        g.fillStyle(0x2d3436); g.fillRect(8, 32, 7, 8); g.fillRect(18, 32, 7, 8);
        g.generateTexture('fighter', 32, 40); g.clear();
      }
      if (!this.textures.exists('enemy') || this.textures.get('enemy').key === '__MISSING') {
        g.fillStyle(0x6c5ce7); g.fillRect(4, 0, 24, 14);
        g.fillStyle(0xb8b5c4); g.fillRect(8, 0, 16, 14);
        g.fillStyle(0x2d3436); g.fillRect(12, 4, 3, 3); g.fillRect(19, 4, 3, 3);
        g.fillStyle(0xff3838); g.fillRect(14, 10, 6, 2);
        g.fillStyle(0x636e72); g.fillRect(4, 14, 24, 18);
        g.fillStyle(0xb8b5c4); g.fillRect(0, 16, 6, 4); g.fillRect(26, 16, 6, 4);
        g.fillStyle(0x2d3436); g.fillRect(8, 32, 7, 8); g.fillRect(18, 32, 7, 8);
        g.generateTexture('enemy', 32, 40); g.clear();
      }
      if (!this.textures.exists('punch') || this.textures.get('punch').key === '__MISSING') {
        g.fillStyle(0xfdcb6e); g.fillCircle(8, 8, 8);
        g.fillStyle(0xffeaa7); g.fillCircle(6, 6, 3);
        g.generateTexture('punch', 16, 16); g.clear();
      }
      if (!this.textures.exists('particle') || this.textures.get('particle').key === '__MISSING') {
        g.fillStyle(0xffffff); g.fillCircle(4, 4, 4);
        g.generateTexture('particle', 8, 8); g.clear();
      }
      g.destroy();

      this.touchLeft = false;
      this.touchRight = false;
      this.touchJump = false;
      this.touchPunch = false;
      this.touchKick = false;

      this.score = 0;
      this.combo = 0;
      this.comboTimer = 0;
      this.maxHealth = 100;
      this.playerHealth = this.maxHealth;
      this.gameOver = false;
      this.wave = 1;
      this.enemiesPerWave = 3;
      this.enemiesSpawned = 0;
      this.enemiesDefeated = 0;
      this.attacking = false;
      this.attackCooldown = 0;
      this.facingRight = true;

      const bg = this.add.graphics();
      bg.fillGradientStyle(0x2d3436, 0x2d3436, 0x636e72, 0x636e72);
      bg.fillRect(0, 0, 800, 500);
      bg.fillStyle(0x1e272e); bg.fillRect(0, 430, 800, 70);
      bg.fillStyle(0x485460, 0.3);
      for (let x = 0; x < 800; x += 80) bg.fillRect(x, 430, 40, 70);

      this.player = this.physics.add.sprite(120, 390, 'fighter')
        .setCollideWorldBounds(true).setScale(2).setDepth(5);
      this.player.body.setSize(20, 36); this.player.body.setOffset(6, 4);

      this.enemies = this.physics.add.group();
      this.attackHitbox = this.physics.add.sprite(0, 0, 'punch')
        .setVisible(false).setActive(false).setScale(1.5);
      this.attackHitbox.body.enable = false;

      this.particles = this.add.particles(0, 0, 'particle', {
        speed: { min: 60, max: 180 }, lifespan: 300, scale: { start: 1.5, end: 0 },
        emitting: false, quantity: 8, tint: [0xd63031, 0xe17055, 0xfdcb6e]
      });

      this.physics.add.overlap(this.attackHitbox, this.enemies, this.onHitEnemy, null, this);

      this.drawHealthBar = (x, y, w, current, max, color) => {
        const bar = this.add.graphics().setDepth(10).setScrollFactor(0);
        bar.fillStyle(0x2d3436); bar.fillRect(x - 1, y - 1, w + 2, 14);
        bar.fillStyle(0x636e72); bar.fillRect(x, y, w, 12);
        const pct = Phaser.Math.Clamp(current / max, 0, 1);
        bar.fillStyle(color); bar.fillRect(x, y, w * pct, 12);
        return bar;
      };

      this.playerHealthBar = null;
      this.refreshPlayerHealth();

      const ts = { fontFamily: 'Segoe UI', fontSize: '18px', fill: '#fff', stroke: '#000', strokeThickness: 2 };
      this.scoreText = this.add.text(12, 8, 'Score: 0', ts).setDepth(10).setScrollFactor(0);
      this.waveText = this.add.text(400, 8, 'Wave 1', { ...ts, fontSize: '16px', fill: '#fdcb6e' })
        .setOrigin(0.5, 0).setDepth(10).setScrollFactor(0);
      this.comboText = this.add.text(400, 250, '', {
        fontFamily: 'Segoe UI', fontSize: '32px', fill: '#fdcb6e', fontStyle: 'bold',
        stroke: '#000', strokeThickness: 4
      }).setOrigin(0.5).setDepth(15).setScrollFactor(0).setAlpha(0);

      this.cursors = this.input.keyboard.createCursorKeys();
      this.shiftKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SHIFT);

      if ('ontouchstart' in window) {
        const ba = 0.3, bd = 1000;
        const bL = this.add.rectangle(50, 460, 70, 70, 0xffffff, ba).setScrollFactor(0).setDepth(bd).setInteractive();
        const bR = this.add.rectangle(140, 460, 70, 70, 0xffffff, ba).setScrollFactor(0).setDepth(bd).setInteractive();
        const bJ = this.add.rectangle(140, 380, 70, 70, 0xffffff, ba).setScrollFactor(0).setDepth(bd).setInteractive();
        const bP = this.add.rectangle(660, 460, 70, 70, 0xfdcb6e, ba).setScrollFactor(0).setDepth(bd).setInteractive();
        const bK = this.add.rectangle(750, 460, 70, 70, 0xff7675, ba).setScrollFactor(0).setDepth(bd).setInteractive();
        this.add.text(50, 460, '\u25C0', { fontSize: '24px', fill: '#fff' }).setOrigin(0.5).setScrollFactor(0).setDepth(bd + 1);
        this.add.text(140, 460, '\u25B6', { fontSize: '24px', fill: '#fff' }).setOrigin(0.5).setScrollFactor(0).setDepth(bd + 1);
        this.add.text(140, 380, '\u25B2', { fontSize: '24px', fill: '#fff' }).setOrigin(0.5).setScrollFactor(0).setDepth(bd + 1);
        this.add.text(660, 460, '\uD83E\uDD4A', { fontSize: '24px' }).setOrigin(0.5).setScrollFactor(0).setDepth(bd + 1);
        this.add.text(750, 460, '\uD83E\uDDB6', { fontSize: '24px' }).setOrigin(0.5).setScrollFactor(0).setDepth(bd + 1);
        const bind = (btn, prop) => {
          btn.on('pointerdown', () => { this[prop] = true; });
          btn.on('pointerup', () => { this[prop] = false; });
          btn.on('pointerout', () => { this[prop] = false; });
        };
        bind(bL, 'touchLeft'); bind(bR, 'touchRight'); bind(bJ, 'touchJump');
        bind(bP, 'touchPunch'); bind(bK, 'touchKick');
      }

      this.spawnTimer = this.time.addEvent({
        delay: 1800, callback: this.spawnEnemy, callbackScope: this, loop: true
      });
      this.spawnEnemy();

      this.enemyHealthBars = new Map();
    }

    refreshPlayerHealth() {
      if (this.playerHealthBar) this.playerHealthBar.destroy();
      this.playerHealthBar = this.drawHealthBar(12, 30, 160, this.playerHealth, this.maxHealth, 0x00b894);
    }

    refreshEnemyHealthBar(enemy) {
      if (this.enemyHealthBars.has(enemy)) this.enemyHealthBars.get(enemy).destroy();
      const bar = this.add.graphics().setDepth(10);
      bar.fillStyle(0x2d3436); bar.fillRect(-20, -30, 40, 6);
      const pct = Phaser.Math.Clamp(enemy.hp / enemy.maxHp, 0, 1);
      bar.fillStyle(0xd63031); bar.fillRect(-20, -30, 40 * pct, 6);
      bar.x = enemy.x; bar.y = enemy.y;
      this.enemyHealthBars.set(enemy, bar);
    }

    update(time, delta) {
      if (this.gameOver) return;

      const speed = 220;
      if (this.cursors.left.isDown || this.touchLeft) {
        this.player.setVelocityX(-speed); this.facingRight = false; this.player.setFlipX(true);
      } else if (this.cursors.right.isDown || this.touchRight) {
        this.player.setVelocityX(speed); this.facingRight = true; this.player.setFlipX(false);
      } else {
        this.player.setVelocityX(0);
      }
      if ((this.cursors.up.isDown || this.touchJump) && this.player.body.touching.down) {
        this.player.setVelocityY(-380);
        this.touchJump = false;
      }

      if (this.attackCooldown > 0) this.attackCooldown -= delta;

      if ((this.cursors.space.isDown || this.touchPunch) && this.attackCooldown <= 0 && !this.attacking) {
        this.performAttack('punch', 15, 250);
        this.touchPunch = false;
      } else if ((this.shiftKey.isDown || this.touchKick) && this.attackCooldown <= 0 && !this.attacking) {
        this.performAttack('kick', 25, 400);
        this.touchKick = false;
      }

      if (this.comboTimer > 0) {
        this.comboTimer -= delta;
        if (this.comboTimer <= 0) this.combo = 0;
      }

      this.enemies.children.iterate(e => {
        if (!e || !e.active) return;
        const bar = this.enemyHealthBars.get(e);
        if (bar) { bar.x = e.x; bar.y = e.y; }

        const dist = Phaser.Math.Distance.Between(e.x, e.y, this.player.x, this.player.y);
        if (dist < 50 && e.attackCooldown <= 0 && !e.stunned) {
          this.playerTakeDamage(8 + this.wave * 2);
          e.attackCooldown = 1200;
        }
        if (e.attackCooldown > 0) e.attackCooldown -= delta;
        if (e.stunned) {
          e.stunTimer -= delta;
          if (e.stunTimer <= 0) { e.stunned = false; e.setTint(0xffffff); }
          return;
        }

        if (dist > 45) {
          const dir = this.player.x < e.x ? -1 : 1;
          e.setVelocityX(dir * (60 + this.wave * 8));
          e.setFlipX(dir > 0);
        } else {
          e.setVelocityX(0);
        }
      });
    }

    performAttack(type, damage, cooldown) {
      this.attacking = true;
      this.attackCooldown = cooldown;
      const ox = this.facingRight ? 40 : -40;
      this.attackHitbox.setPosition(this.player.x + ox, this.player.y);
      this.attackHitbox.body.enable = true;
      this.attackHitbox.setActive(true).setVisible(true);
      this.attackHitbox.attackDamage = damage;
      this.attackHitbox.attackType = type;

      if (type === 'kick') this.attackHitbox.setTint(0xff7675);
      else this.attackHitbox.setTint(0xfdcb6e);

      this.time.delayedCall(100, () => {
        this.attackHitbox.body.enable = false;
        this.attackHitbox.setActive(false).setVisible(false);
        this.attacking = false;
      });
    }

    onHitEnemy(hitbox, enemy) {
      if (!hitbox.active || enemy.stunned) return;

      const dmg = hitbox.attackDamage + Math.floor(this.combo * 2);
      enemy.hp -= dmg;
      enemy.stunned = true;
      enemy.stunTimer = 300;
      enemy.setTint(0xff0000);

      const kb = this.facingRight ? 300 : -300;
      enemy.setVelocityX(kb);
      enemy.setVelocityY(-120);

      if (this.cache.audio.exists('hitSfx')) this.sound.play('hitSfx');
      this.particles.emitParticleAt(enemy.x, enemy.y);

      this.combo++;
      this.comboTimer = 1500;
      if (this.combo >= 2) {
        this.comboText.setText(this.combo + 'x COMBO!');
        this.comboText.setAlpha(1).setScale(0.5);
        this.tweens.add({
          targets: this.comboText, scale: 1.2, alpha: 0, duration: 800,
          ease: 'Power2'
        });
      }

      this.refreshEnemyHealthBar(enemy);

      if (enemy.hp <= 0) {
        this.defeatEnemy(enemy);
      }
    }

    defeatEnemy(enemy) {
      if (this.cache.audio.exists('explosionSfx')) this.sound.play('explosionSfx');
      this.particles.emitParticleAt(enemy.x, enemy.y);
      if (this.enemyHealthBars.has(enemy)) {
        this.enemyHealthBars.get(enemy).destroy();
        this.enemyHealthBars.delete(enemy);
      }
      enemy.destroy();

      const waveBonus = this.wave * 5;
      const comboBonus = this.combo * 10;
      this.score += 50 + waveBonus + comboBonus;
      this.scoreText.setText('Score: ' + this.score);
      this.enemiesDefeated++;

      if (this.enemiesDefeated >= this.enemiesPerWave) {
        this.wave++;
        this.enemiesPerWave = 3 + this.wave;
        this.enemiesDefeated = 0;
        this.enemiesSpawned = 0;
        this.waveText.setText('Wave ' + this.wave);

        const wt = this.add.text(400, 150, 'WAVE ' + this.wave, {
          fontFamily: 'Segoe UI', fontSize: '48px', fill: '#fdcb6e', fontStyle: 'bold',
          stroke: '#000', strokeThickness: 5
        }).setOrigin(0.5).setDepth(20).setAlpha(0);
        this.tweens.add({
          targets: wt, alpha: 1, y: 130, duration: 500, yoyo: true, hold: 600,
          onComplete: () => wt.destroy()
        });

        const newDelay = Math.max(600, 1800 - this.wave * 150);
        this.spawnTimer.remove();
        this.spawnTimer = this.time.addEvent({
          delay: newDelay, callback: this.spawnEnemy, callbackScope: this, loop: true
        });
      }
    }

    playerTakeDamage(amount) {
      this.playerHealth -= amount;
      this.refreshPlayerHealth();
      this.player.setTint(0xff0000);
      this.time.delayedCall(150, () => { if (!this.gameOver) this.player.setTint(0xffffff); });

      if (this.playerHealth <= 0) {
        this.playerHealth = 0;
        this.refreshPlayerHealth();
        this.showGameOver();
      }
    }

    spawnEnemy() {
      if (this.gameOver) return;
      if (this.enemiesSpawned >= this.enemiesPerWave) return;

      const side = Math.random() < 0.8 ? 820 : -20;
      const e = this.enemies.create(side, 390, 'enemy').setScale(2).setCollideWorldBounds(true).setDepth(4);
      e.body.setSize(20, 36); e.body.setOffset(6, 4);
      e.maxHp = 30 + this.wave * 15;
      e.hp = e.maxHp;
      e.attackCooldown = 800;
      e.stunned = false;
      e.stunTimer = 0;
      this.refreshEnemyHealthBar(e);
      this.enemiesSpawned++;
    }

    showGameOver() {
      this.gameOver = true;
      this.physics.pause();
      this.player.setTint(0x880000);

      this.add.rectangle(400, 250, 800, 500, 0x000000, 0.75).setDepth(20);
      this.add.text(400, 170, 'GAME OVER', {
        fontSize: '52px', fill: '#d63031', fontFamily: 'Segoe UI', fontStyle: 'bold',
        stroke: '#000', strokeThickness: 5
      }).setOrigin(0.5).setDepth(21);
      this.add.text(400, 240, 'Score: ' + this.score, {
        fontSize: '28px', fill: '#fff', fontFamily: 'Segoe UI'
      }).setOrigin(0.5).setDepth(21);
      this.add.text(400, 280, 'Wave: ' + this.wave + '  |  Combo Record: ' + this.combo, {
        fontSize: '18px', fill: '#fdcb6e', fontFamily: 'Segoe UI'
      }).setOrigin(0.5).setDepth(21);
      this.add.text(400, 340, 'Click to Restart', {
        fontSize: '20px', fill: '#e17055', fontFamily: 'Segoe UI'
      }).setOrigin(0.5).setDepth(21);

      this.input.once('pointerdown', () => this.scene.restart());
    }
  }

  new Phaser.Game({
    type: Phaser.AUTO, width: 800, height: 500, parent: 'game-container',
    backgroundColor: '#2d3436',
    physics: { default: 'arcade', arcade: { gravity: { y: 600 }, debug: false } },
    scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
    scene: FightScene
  });
  </script>
</body>
</html>
