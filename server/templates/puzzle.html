<!DOCTYPE html>
<html>
<head>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: linear-gradient(135deg, #4a1a6b 0%, #2a1040 50%, #1a0830 100%);
      min-height: 100vh; display: flex; align-items: center; justify-content: center;
      font-family: 'Segoe UI', sans-serif;
    }
    #game { border-radius: 12px; overflow: hidden; box-shadow: 0 8px 32px rgba(0,0,0,0.5); }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.86.0/dist/phaser.min.js"></script>
</head>
<body>
<div id="game"></div>
<script>
const COLS = 7, ROWS = 8, TILE = 56, PAD = 40;
const GW = COLS * TILE + PAD * 2, GH = ROWS * TILE + PAD * 2 + 50;
const COLORS = [0xff4466, 0x44aaff, 0x44dd44, 0xffaa22, 0xdd44ff, 0x44ffdd];
const COLOR_NAMES = ['red', 'blue', 'green', 'orange', 'purple', 'cyan'];

class Match extends Phaser.Scene {
  constructor() { super('Match'); }

  create() {
    this.score = 0; this.selected = null;
    this.canInput = true; this.grid = [];

    if (!this.textures.exists('tile_0')) {
      COLORS.forEach((c, i) => {
        const g = this.make.graphics({ add: false });
        g.fillStyle(c); g.fillRoundedRect(2, 2, TILE - 4, TILE - 4, 8);
        g.fillStyle(0xffffff, 0.3); g.fillRoundedRect(6, 6, TILE - 16, 14, 4);
        g.generateTexture('tile_' + i, TILE, TILE); g.destroy();
      });
      const sg = this.make.graphics({ add: false });
      sg.lineStyle(3, 0xffffff); sg.strokeRoundedRect(2, 2, TILE - 4, TILE - 4, 8);
      sg.generateTexture('sel', TILE, TILE); sg.destroy();
    }

    this.add.rectangle(GW / 2, GH / 2, GW, GH, 0x1a0a2e);
    this.scoreText = this.add.text(GW / 2, 18, 'Score: 0', { fontSize: '24px', fill: '#ffcc00', stroke: '#000', strokeThickness: 3 }).setOrigin(0.5).setDepth(10);
    this.selBox = this.add.image(-100, -100, 'sel').setDepth(5).setAlpha(0.9);

    for (let r = 0; r < ROWS; r++) {
      this.grid[r] = [];
      for (let c = 0; c < COLS; c++) {
        let type;
        do { type = Phaser.Math.Between(0, COLORS.length - 1); }
        while (this.wouldMatch(r, c, type));
        this.grid[r][c] = this.createTile(r, c, type);
      }
    }

    this.input.on('gameobjectdown', (ptr, obj) => {
      if (!this.canInput || !obj.tileData) return;
      const { row, col } = obj.tileData;
      if (!this.selected) {
        this.selected = { row, col };
        this.selBox.setPosition(obj.x, obj.y);
      } else {
        const dr = Math.abs(this.selected.row - row);
        const dc = Math.abs(this.selected.col - col);
        if ((dr === 1 && dc === 0) || (dr === 0 && dc === 1)) {
          this.trySwap(this.selected.row, this.selected.col, row, col);
        }
        this.selected = null;
        this.selBox.setPosition(-100, -100);
      }
    });
  }

  tileX(c) { return PAD + c * TILE + TILE / 2; }
  tileY(r) { return PAD + 50 + r * TILE + TILE / 2; }

  wouldMatch(r, c, type) {
    if (c >= 2 && this.grid[r]?.[c-1]?.tileData?.type === type && this.grid[r]?.[c-2]?.tileData?.type === type) return true;
    if (r >= 2 && this.grid[r-1]?.[c]?.tileData?.type === type && this.grid[r-2]?.[c]?.tileData?.type === type) return true;
    return false;
  }

  createTile(r, c, type) {
    const t = this.add.image(this.tileX(c), this.tileY(r), 'tile_' + type).setInteractive().setDepth(2);
    t.tileData = { row: r, col: c, type };
    return t;
  }

  trySwap(r1, c1, r2, c2) {
    this.canInput = false;
    const a = this.grid[r1][c1], b = this.grid[r2][c2];
    this.grid[r1][c1] = b; this.grid[r2][c2] = a;
    b.tileData.row = r1; b.tileData.col = c1;
    a.tileData.row = r2; a.tileData.col = c2;

    this.tweens.add({ targets: a, x: this.tileX(c2), y: this.tileY(r2), duration: 150 });
    this.tweens.add({ targets: b, x: this.tileX(c1), y: this.tileY(r1), duration: 150, onComplete: () => {
      const matches = this.findMatches();
      if (matches.length === 0) {
        this.grid[r1][c1] = a; this.grid[r2][c2] = b;
        a.tileData.row = r1; a.tileData.col = c1;
        b.tileData.row = r2; b.tileData.col = c2;
        this.tweens.add({ targets: a, x: this.tileX(c1), y: this.tileY(r1), duration: 150 });
        this.tweens.add({ targets: b, x: this.tileX(c2), y: this.tileY(r2), duration: 150, onComplete: () => { this.canInput = true; }});
      } else {
        this.processMatches(matches);
      }
    }});
  }

  findMatches() {
    const matched = new Set();
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS - 2; c++) {
        const t = this.grid[r][c]?.tileData?.type;
        if (t !== undefined && this.grid[r][c+1]?.tileData?.type === t && this.grid[r][c+2]?.tileData?.type === t) {
          matched.add(r+','+c); matched.add(r+','+(c+1)); matched.add(r+','+(c+2));
        }
      }
    }
    for (let c = 0; c < COLS; c++) {
      for (let r = 0; r < ROWS - 2; r++) {
        const t = this.grid[r][c]?.tileData?.type;
        if (t !== undefined && this.grid[r+1]?.[c]?.tileData?.type === t && this.grid[r+2]?.[c]?.tileData?.type === t) {
          matched.add(r+','+c); matched.add((r+1)+','+c); matched.add((r+2)+','+c);
        }
      }
    }
    return [...matched].map(s => { const p = s.split(','); return { r: +p[0], c: +p[1] }; });
  }

  processMatches(matches) {
    this.score += matches.length * 50;
    this.scoreText.setText('Score: ' + this.score);

    matches.forEach(({ r, c }) => {
      const tile = this.grid[r][c];
      if (tile) {
        this.tweens.add({ targets: tile, scaleX: 0, scaleY: 0, alpha: 0, duration: 200, onComplete: () => tile.destroy() });
        this.grid[r][c] = null;
      }
    });

    this.time.delayedCall(250, () => this.dropTiles());
  }

  dropTiles() {
    let moved = false;
    for (let c = 0; c < COLS; c++) {
      for (let r = ROWS - 1; r >= 0; r--) {
        if (!this.grid[r][c]) {
          for (let above = r - 1; above >= 0; above--) {
            if (this.grid[above][c]) {
              this.grid[r][c] = this.grid[above][c];
              this.grid[above][c] = null;
              this.grid[r][c].tileData.row = r;
              this.grid[r][c].tileData.col = c;
              this.tweens.add({ targets: this.grid[r][c], y: this.tileY(r), duration: 150 });
              moved = true;
              break;
            }
          }
        }
      }
      for (let r = 0; r < ROWS; r++) {
        if (!this.grid[r][c]) {
          const type = Phaser.Math.Between(0, COLORS.length - 1);
          const tile = this.createTile(r, c, type);
          tile.y = this.tileY(-1);
          this.tweens.add({ targets: tile, y: this.tileY(r), duration: 200, delay: 50 });
          this.grid[r][c] = tile;
          moved = true;
        }
      }
    }

    this.time.delayedCall(300, () => {
      const newMatches = this.findMatches();
      if (newMatches.length > 0) {
        this.processMatches(newMatches);
      } else {
        this.canInput = true;
      }
    });
  }
}

new Phaser.Game({
  type: Phaser.AUTO, width: GW, height: GH, parent: 'game',
  backgroundColor: '#1a0a2e', scene: Match
});
</script>
</body>
</html>
